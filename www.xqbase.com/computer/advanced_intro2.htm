<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=gb_2312-80">
<meta name="Owner" content>
<meta name="Reply-To" content>
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>高级搜索方法――简介(二)</title>
</head>

<body background="../background.gif">

<dl>
    <div align="center"><center>
    <dt>《对弈程序基本技术》专题</dt>
    </center></div><div align="center"><center>
    <dt>　</dt>
    </center></div><div align="center"><center>
    <dt><font size="6" face="Arial"><strong>Alpha-Beta</strong></font><font
        size="6" face="隶书">搜索的诸多变种</font></dt>
    </center></div><div align="center"><center>
    <dt>　</dt>
    </center></div><div align="center"><center>
    <dt><font face="Times New Roman">David Eppstein */</font>文 </dt>
    </center></div><div align="center"><center>
    <dt><font face="Times New Roman">* </font>加州爱尔文大学<font
        face="Times New Roman">(UC Irvine)</font>信息与计算机科学系
    </dt>
    </center></div><div align="center"><center>
    <dt>　</dt>
    </center></div>
    <dt><font size="3">　　尽管我们已经讨论过</font><font
        size="3" face="Times New Roman">Alpha-Beta</font><font
        size="3">搜索简单有效，还是有很多方法试图更有效地对博弈树进行搜索。它们中的大部分思想就是，如果认为介于</font><font
        size="3" face="Times New Roman">Alpha</font><font
        size="3">和</font><font size="3" face="Times New Roman">Beta</font><font
        size="3">间的评价是感兴趣的，而其他评价都是不感兴趣的，那么对不感兴趣的评价作截断会让</font><font
        size="3" face="Times New Roman">Alpha-Beta</font><font
        size="3">更有效。如果我们把</font><font size="3"
        face="Times New Roman">Alpha</font><font size="3">和</font><font
        size="3" face="Times New Roman">Beta</font><font size="3">的间距缩小，那么感兴趣的评价会更少，截断会更多。</font></dt>
    <dt>　　首先让我们回顾一下原始的<font
        face="Times New Roman">Alpha-Beta</font>搜索，忽略散列表和“<a
        href="other_winning.htm" target="_blank">用当前层数调整胜利值</a>”的细节。</dt>
    <dt>　</dt>
    <dd>// 基本的Alpha-Beta搜索</dd>
    <dd>int alphabeta(int depth, int alpha, int beta) {</dd>
    <dd>　move bestmove;</dd>
    <dd>　if (棋局结束 || depth &lt;= 0) {</dd>
    <dd>　　return eval();</dd>
    <dd>　}</dd>
    <dd>　for (每个合理着法 m) {</dd>
    <dd>　　执行着法 m;</dd>
    <dd>　　score = -alphabeta(depth - 1, -beta, -alpha);</dd>
    <dd>　　if (score &gt;= alpha) {</dd>
    <dd>　　　alpha = score;</dd>
    <dd>　　　bestmove = m;</dd>
    <dd>　　}</dd>
    <dd>　　撤消着法 m;</dd>
    <dd>　　if (alpha &gt;= beta) {</dd>
    <dd>　　　break;</dd>
    <dd>　　}</dd>
    <dd>　}</dd>
    <dd>　return alpha;</dd>
    <dd>}</dd>
    <dt>　</dt>
    <dt><font size="5" face="楷体_GB2312"><strong>超出边界</strong></font><font
        size="5" face="Arial"><strong>(Fail-Soft)</strong></font><font
        size="5" face="楷体_GB2312"><strong>的</strong></font><font
        size="5" face="Arial"><strong>Alpha-Beta</strong></font></dt>
    <dt>　</dt>
    <dt>　　以上代码总是返回<font
        face="Times New Roman">Alpha</font>、<font
        face="Times New Roman">Beta</font>或在<font
        face="Times New Roman">Alpha</font>和<font
        face="Times New Roman">Beta</font>之间的数。换句话说，当某个值不感兴趣时，从返回值无法得到任何信息。原因就是当前值被变量<font
        face="Times New Roman">Alpha</font>所保存，它从感兴趣的值的窗口下沿开始一直增长的，没有可能返回比<font
        face="Times New Roman">Alpha</font>更小的值。一个对<font
        face="Times New Roman">Alpha-Beta</font>的简单改进就是把当前评价和<font
        face="Times New Roman">Alpha</font>分开保存。下面的伪代码用常数“<font
        face="Times New Roman">WIN</font>”表示最大评价，它可以在<font
        face="Times New Roman">Alpha-Beta</font>搜索中返回任何评价。</dt>
    <dt>　</dt>
    <dd>// 超出边界的Alpha-Beta搜索</dd>
    <dd>int alphabeta(int depth, int alpha, int beta) {</dd>
    <dd>　move bestmove;</dd>
    <dd>　int current = -WIN;</dd>
    <dd>　if (棋局结束 || depth &lt;= 0) {</dd>
    <dd>　　return eval();</dd>
    <dd>　}</dd>
    <dd>　for (每个可能的着法 m) {</dd>
    <dd>　　执行着法 m;</dd>
    <dd>　　score = -alphabeta(depth - 1, -beta, -alpha);</dd>
    <dd>　　撤消着法 m;</dd>
    <dd>　　if (score &gt;= current) {</dd>
    <dd>　　　current = score;</dd>
    <dd>　　　bestmove = m;</dd>
    <dd>　　　if (score &gt;= alpha) {</dd>
    <dd>　　　　alpha = score;</dd>
    <dd>　　　}</dd>
    <dd>　　　if (score &gt;= beta) {</dd>
    <dd>　　　　break; // <font color="#0000FF">【译注：这里可以直接返回score、current或alpha，如果返回beta，则是不会高出边界的Alpha-Beta搜索。】</font></dd>
    <dd>　　　}</dd>
    <dd>　　}</dd>
    <dd>　}</dd>
    <dd>　return current;</dd>
    <dd>}</dd>
    <dt>　</dt>
    <dt>　　这样改动以后，就可以知道比以前稍多一点的信息。如果返回值<font
        face="Times New Roman"><em>x</em></font>等于或小于<font
        face="Times New Roman">Alpha</font>，我们仍然不知道局面的确切值<font
        face="Times New Roman">(</font>因为我们可能在搜索中裁剪了一些线路<font
        face="Times New Roman">)</font>，但是我们知道确切值最多是<font
        face="Times New Roman"><em>x</em></font>。类似地，如果<font
        face="Times New Roman"><em>x</em></font>大于或等于<font
        face="Times New Roman">Beta</font>，我们就知道搜索值至少是<font
        face="Times New Roman"><em>x</em></font>。这些微小的上界和下界变化不会影响搜索本身，但是它们能导致散列表命中率的提高。超出边界的<font
        face="Times New Roman">Alpha-Beta</font>搜索对下面要介绍的<font
        face="Times New Roman">MTD(<em>f</em>)</font>算法有重要作用。</dt>
    <dt>　</dt>
    <dt><font size="5" face="楷体_GB2312"><strong>期望搜索</strong></font></dt>
    <dt>　</dt>
    <dt>　　这个方法不是代替<font
        face="Times New Roman">Alpha-Beta</font>的，只是从外部改边一个途径来调用搜索过程。通常用<font
        face="Times New Roman">Alpha-Beta</font>找最好路线时，可以调用：</dt>
    <dd>　</dd>
    <dd>alphabeta(depth, -WIN, WIN)</dd>
    <dt>　</dt>
    <dt>　　这里 <font face="Symbol">-</font><font
        face="Times New Roman">WIN </font>和 <font
        face="Times New Roman">WIN </font>之间的范围很大，表明我们不知道搜索值是多少，因此任何可能的值都必须考虑。随后，要走的那步保存在搜索函数外部的变量中。</dt>
    <dt>　　期望搜索的不同之处在于，我们可以人为地指定一个狭窄窗口<font
        face="Times New Roman">(</font>用前一个搜索值为中心<font
        face="Times New Roman">)</font>，对搜索通常是有帮助的。如果你搜索失败，必须加宽窗口重新搜索：</dt>
    <dt>　</dt>
    <dd>// 期望搜索</dd>
    <dd>int alpha = previous - WINDOW;</dd>
    <dd>int beta = previous + WINDOW;</dd>
    <dd>for ( ; ; ) {</dd>
    <dd>　score = alphabeta(depth, alpha, beta);</dd>
    <dd>　if (score &lt;= alpha) {</dd>
    <dd>　　alpha　= -WIN;</dd>
    <dd>　} else if (score &gt;= beta) {</dd>
    <dd>　　beta = WIN;</dd>
    <dd>　} else {</dd>
    <dd>　　break;</dd>
    <dd>　}</dd>
    <dd>}</dd>
    <dt>　</dt>
    <dt>　　权衡狭窄搜索所节约的时间，和因为失败而重新搜索的时间，可以决定常数
        <font face="Times New Roman">WINDOW </font>的大小。在国际象棋中，典型的值也许是半个兵。期望搜索的变体有，搜索失败时适当增加窗口宽度，或者用初始窗口而没必要以前一次搜索结果为中心，等等。</dt>
    <dt>　</dt>
    <dt><font size="5" face="Arial"><strong>MTD(</strong><em><strong>f</strong></em><strong>)</strong></font></dt>
    <dt>　</dt>
    <dt>　　这个技术跟期望搜索一样，只是在调用<font
        face="Times New Roman">Alpha-Beta</font>时对初始值进行调整。搜索窗口越窄搜索就越快，这个技术的思想就是让搜索窗口尽可能的窄：始终用“<font
        face="Times New Roman">beta = alpha + 1</font>”来调用<font
        face="Times New Roman">Alpha-Beta</font>。用这样一个“零宽度”搜索的作用是用<font
        face="Times New Roman">Alpha</font>和确切值作比较：如果搜索的返回值最多是<font
        face="Times New Roman">Alpha</font>，那么确切值本身最多是<font
        face="Times New Roman">Alpha</font>，相反确切值大于<font
        face="Times New Roman">Alpha</font>。</dt>
    <dt>　　我们可以用这个思想对确切值作二分搜索：</dt>
    <dt>　</dt>
    <dd>int alpha = -WIN;</dd>
    <dd>int beta = +WIN;</dd>
    <dd>while (beta &gt; alpha + 1) {</dd>
    <dd>　int test = (alpha + beta) / 2;</dd>
    <dd>　if (alphabeta(depth, test, test + 1) &lt;= test) {</dd>
    <dd>　　beta = test;</dd>
    <dd>　} else {</dd>
    <dd>　　alpha = test + 1;</dd>
    <dd>　}</dd>
    <dd>}</dd>
    <dt>　</dt>
    <dt>　　但是，这样会导致大规模的搜索<font
        face="Times New Roman">(</font>即 <font
        face="Times New Roman">WIN </font>和 <font
        face="Times New Roman">-WIN</font> 的差的对数<font
        face="Times New Roman">)</font>。而<font
        face="Times New Roman">MTD(<em>f</em>)</font>的思想则是用超出边界的<font
        face="Times New Roman">Alpha-Beta</font>对搜索进行控制：每次调用超出边界的<font
        face="Times New Roman">Alpha-Beta</font>就会返回一个值更接近于最终值，如果用这个搜索值作为下次测试的开始，我们最终会达到收敛。</dt>
    <dd>　</dd>
    <dd>// MTD(f)</dd>
    <dd>int test = 0;</dd>
    <dd>for ( ; ; ) {</dd>
    <dd>　score = alphabeta(depth, test, test + 1);</dd>
    <dd>　if (test == score) {</dd>
    <dd>　　break;</dd>
    <dd>　}</dd>
    <dd>　test = score;</dd>
    <dd>}</dd>
    <dt>　</dt>
    <dt><font size="3">　　不幸的是，它和散列表之间的复杂作用会导致这个过程陷入无限循环，所以必须加上额外的代码，如果迭代次数太多而没有收敛，就必须中止搜索。</font></dt>
    <dt><font size="3">　　</font><font size="3"
        face="Times New Roman">MTD(<em>f</em>)</font><font
        size="3">的一个大的优势在于我们可以简化</font><font
        size="3" face="Times New Roman">Alpha-Beta</font><font
        size="3">搜索，因为它只需要两个参数</font><font
        size="3" face="Times New Roman">(</font><font size="3">深度和</font><font
        size="3" face="Times New Roman">Alpha)</font><font
        size="3">而不是三个。</font><font color="#0000FF">【据说这样做可以提高并行计算的效率，遗憾的是译者对并行计算一窍不通。】</font></dt>
    <dt><font color="#0000FF">　　【为了对</font><font
        color="#0000FF" face="Times New Roman">MTD(<em>f</em>)</font><font
        color="#0000FF">有更详细的了解，译者查阅了该算法的发明者</font><font
        color="#0000FF" face="Times New Roman">Plaat</font><font
        color="#0000FF">的网站，他提供的</font><font
        color="#0000FF" face="Times New Roman">MTD(<em>f</em>)</font><font
        color="#0000FF">代码中用了两个边界，可以防止迭代过程中出现振荡而不收敛的情况，代码如下</font><font
        color="#0000FF" face="Times New Roman">(</font><font
        color="#0000FF">原来是</font><font color="#0000FF"
        face="Times New Roman">Pascal</font><font color="#0000FF">语言，现被译者转写为</font><font
        color="#0000FF" face="Times New Roman">C</font><font
        color="#0000FF">语言</font><font color="#0000FF"
        face="Times New Roman">)</font><font color="#0000FF">：</font></dt>
    <dd>　</dd>
    <dd><font color="#0000FF">int MTDF(int test, int depth) {</font></dd>
    <dd><font color="#0000FF">　int score, beta, upperbound,
        lowerbound;</font></dd>
    <dd><font color="#0000FF">　score = test;</font></dd>
    <dd><font color="#0000FF">　upperbound = +INFINITY;</font></dd>
    <dd><font color="#0000FF">　lowerbound = -INFINITY;</font></dd>
    <dd><font color="#0000FF">　do {</font></dd>
    <dd><font color="#0000FF">　　beta = (score == lowerbound ?
        score + 1 : score);</font></dd>
    <dd><font color="#0000FF">　　score = alphabeta(depth, beta
        - 1, beta);</font></dd>
    <dd><font color="#0000FF">　　(score &lt; beta ? upperbound
        : lowerbound) = score;</font></dd>
    <dd><font color="#0000FF">　} while (lowerbound &lt;
        upperbound);</font></dd>
    <dd><font color="#0000FF">　return score;</font></dd>
    <dd><font color="#0000FF">}</font></dd>
    <dt>　</dt>
    <dt><font color="#0000FF">　　而关于</font><font
        color="#0000FF" face="Times New Roman">MTD(<em>f</em>)</font><font
        color="#0000FF">的使用另有以下几点技巧：</font></dt>
    <dt><font color="#0000FF">　　</font><font color="#0000FF"
        face="Times New Roman">(1) </font><font color="#0000FF">通常试探值并不一定设成零，而是用迭代加深的形式由浅一层的</font><font
        color="#0000FF" face="Times New Roman">MTD(<em>f</em>)</font><font
        color="#0000FF">搜索给出；</font></dt>
    <dt><font color="#0000FF">　　</font><font color="#0000FF"
        face="Times New Roman">(2) </font><font color="#0000FF">局面评价得越粗糙，</font><font
        color="#0000FF" face="Times New Roman">MTD(<em>f</em>)</font><font
        color="#0000FF">的效率越高，例如国际象棋中可使一个兵的价值由</font><font
        color="#0000FF" face="Times New Roman">100</font><font
        color="#0000FF">降低为</font><font color="#0000FF"
        face="Times New Roman">10</font><font color="#0000FF">，其他子力也相应比例降低，以提高</font><font
        color="#0000FF" face="Times New Roman">MTD(<em>f</em>)</font><font
        color="#0000FF">的效率</font><font color="#0000FF"
        face="Times New Roman">(</font><font color="#0000FF">但粗糙的局面评价函数却不利于迭代加深启发，因此需要寻求一个均衡点</font><font
        color="#0000FF" face="Times New Roman">)</font><font
        color="#0000FF">；</font></dt>
    <dt><font color="#0000FF">　　</font><font color="#0000FF"
        face="Times New Roman">(3) </font><font color="#0000FF">零宽度窗口的搜索需要置换表的有力支持，因此称为“用存储器增强的试探驱动器”</font><font
        color="#0000FF" face="Times New Roman">(Memory-enhanced
        Test Driver</font><font color="#0000FF">，即</font><font
        color="#0000FF" face="Times New Roman">MTD)</font><font
        color="#0000FF">，它只需要传递两个参数</font><font
        color="#0000FF" face="Times New Roman">(</font><font
        color="#0000FF">深度</font><font color="#0000FF"
        face="Times New Roman"><em>n</em></font><font
        color="#0000FF">和试探值</font><font color="#0000FF"
        face="Times New Roman"><em>f</em>)</font><font
        color="#0000FF">，故得名为</font><font
        color="#0000FF" face="Times New Roman">MTD(<em>n</em>,<em>f</em>)</font><font
        color="#0000FF">，缩写为</font><font color="#0000FF"
        face="Times New Roman">MTD(<em>f</em>)</font><font
        color="#0000FF">。】</font></dt>
    <dt>　</dt>
    <dt><font size="5" face="Arial"><strong>PVS</strong></font></dt>
    <dt>　</dt>
    <dt>　　或许最好的<font face="Times New Roman">Alpha-Beta</font>变体，要算是这些名称了：负值侦察<font
        face="Times New Roman">(NegaScout)</font>和主要变例搜索<font
        face="Times New Roman">(Principal Variation Search</font>，简称<font
        face="Times New Roman">PVS)</font>。这个思想就是当第一次迭代搜索时找到最好的值，那么<font
        face="Times New Roman">Alpha-Beta</font>搜索的效率最高。对着法列表进行排序，或者把最好的着法保存到散列表中，这些技术可能让第一个着法成为最佳着法。如果真是如此，我们就可以假设其他着法不可能是好的着法，从而对它们快速地搜索过去。</dt>
    <dt>　　因此<font face="Times New Roman">PVS</font>对第一个搜索使用正常的窗口，而后续搜索使用零宽度的窗口，来对每个后续着法和第一个着法作比较。只有当零窗口搜索失败后才去做正常的搜索。</dt>
    <dd>　</dd>
    <dd>// 主要变例搜索(超出边界的版本)</dd>
    <dd>int alphabeta(int depth, int alpha, int beta) {</dd>
    <dd>　move bestmove, current;</dd>
    <dd>　if (棋局结束 || depth &lt;= 0) {</dd>
    <dd>　　return eval();</dd>
    <dd>　}</dd>
    <dd>　move m = 第一个着法;</dd>
    <dd>　执行着法 m;</dd>
    <dd>　current = -alphabeta(depth - 1, -beta, -alpha);</dd>
    <dd>　撤消着法 m;</dd>
    <dd>　for (其余的每个着法 m) {</dd>
    <dd>　　执行着法 m;</dd>
    <dd>　　score = -alphabeta(depth - 1, -alpha - 1, -alpha);</dd>
    <dd>　　if (score &gt; alpha &amp;&amp; score &lt; beta) {</dd>
    <dd>　　　score = -alphabeta(depth - 1, -beta, -alpha);</dd>
    <dd>　　}</dd>
    <dd>　　撤消着法 m;</dd>
    <dd>　　if (score &gt;= current) {</dd>
    <dd>　　　current = score;</dd>
    <dd>　　　bestmove = m;</dd>
    <dd>　　　if (score &gt;= alpha) {</dd>
    <dd>　　　　alpha = score;</dd>
    <dd>　　　}</dd>
    <dd>　　　if (score &gt;= beta) {</dd>
    <dd>　　　　break;</dd>
    <dd>　　　}</dd>
    <dd>　　}</dd>
    <dd>　}</dd>
    <dd>　return current;</dd>
    <dd>}</dd>
    <dt>　</dt>
    <dt>　　这个算法跟<font face="Times New Roman">MTD(<em>f</em>)</font>有个同样的优势，即搜索树的大多数结点都以零宽度的窗口搜索，可以用双参数的<font
        face="Times New Roman">Alpha-Beta</font>。由于“<font
        face="Times New Roman">Beta &gt; Alpha + 1</font>”的调用非常少，因此不必担心额外的工作<font
        face="Times New Roman">(</font>例如保存最佳着法以供将来使用<font
        face="Times New Roman">)</font>会占用很多时间。<font
        color="#0000FF">【原作者的意思是，调用零宽度窗口的搜索时，可以免去保存最佳着法等操作，因此可以省下不少时间。】</font></dt>
    <dt>　</dt>
    <dt><font size="5" face="楷体_GB2312"><strong>推荐</strong></font></dt>
    <dt>　</dt>
    <dt>　　我自己的程序结合了期望搜索<font
        face="Times New Roman">(</font>用在整个搜索过程以外<font
        face="Times New Roman">)</font>和<font
        face="Times New Roman">PVS(</font>用在搜索过程内部<font
        face="Times New Roman">)</font>。但是不同的棋类游戏不一样，由于这些搜索不难实现，所以要在这些方法中进行选择或调节参数，就必须对它们逐一实现并做一些试验。它们都必须返回同样的搜索值<font
        face="Times New Roman">(</font>如果受散列表影响，那么至少是相近的值<font
        color="#0000FF">【例如常规的</font><font
        color="#0000FF" face="Times New Roman">Alpha-Beta</font><font
        color="#0000FF">搜索和超出边界的</font><font
        color="#0000FF" face="Times New Roman">Alpha-Beta</font><font
        color="#0000FF">搜索，在使用散列表时可能会返回不同的值】</font><font
        face="Times New Roman">)</font>，但搜索的结点数会不同。在你的棋类的典型局面中，能使搜索树最小的方法则被采纳。</dt>
    <dt>　</dt>
    <dt>　　原文：<a
        href="http://www.ics.uci.edu/~eppstein/180a/990202b.html"
        target="_blank"><font face="Times New Roman">http://www.ics.uci.edu/~eppstein/180a/990202b.html</font></a></dt>
    <dt>　　译者：象棋百科全书网 <font
        face="Times New Roman">(</font><a
        href="mailto:webmaster@xqbase.com"><font
        face="Times New Roman">webmaster@xqbase.com</font></a><font
        face="Times New Roman">)</font></dt>
    <dt>　　类型：全译加译注</dt>
</dl>

<dir>
    <li>上一篇　<a href="advanced_intro1.htm">高级搜索方法――简介<font
        face="Times New Roman">(</font>一<font
        face="Times New Roman">)</font></a></li>
    <li>下一篇　<a href="advanced_quiescent.htm">高级搜索方法――静态搜索</a></li>
    <li>返　回　<a href="../computer.htm">象棋百科全书――电脑象棋</a></li>
</dir>
<div align="center"><center>

<table border="0">
    <tr>
        <td><p align="center"><a
        href="http://www.xqbase.com/" target="_blank"><img
        src="../xqbase.gif" border="0" width="88"
        height="31"></a></p>
        </td>
    </tr>
    <tr>
        <td><a href="http://www.xqbase.com/"
        target="_blank"><font size="2" face="Arial"><strong>www.xqbase.com</strong></font></a></td>
    </tr>
</table>
</center></div>
</body>
</html>
