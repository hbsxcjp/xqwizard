<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=gb_2312-80">
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>其他策略――主要变例的获取</title>
</head>

<body background="../background.gif">

<dl>
    <div align="center"><center>
    <dt>《对弈程序基本技术》专题 </dt>
    </center></div><div align="center"><center>
    <dt>　</dt>
    </center></div><div align="center"><center>
    <dt><font size="6" face="隶书">获取主要变例</font></dt>
    </center></div><div align="center"><center>
    <dt>　</dt>
    </center></div><div align="center"><center>
    <dt><font face="Times New Roman">Bruce Moreland / </font>文</dt>
    </center></div>
    <dt>　</dt>
    <dt><font size="5" face="楷体_GB2312"><strong>要点</strong></font></dt>
    <dt>　</dt>
    <dt>　　经常有人问，如何在搜索完成后提取主要变例。主要变例是程序认为的对双方来说都是最好的着法线路。它不会由未修改的“<a
        href="search_alphabeta.htm" target="_blank"><font
        face="Times New Roman">Alpha-Beta</font>函数</a>”来获得，所有的<font
        face="Times New Roman">Alpha-Beta</font>都只返回数值。</dt>
    <dt>　　我们需要做的是对普通的<font
        face="Times New Roman">Alpha-Beta</font>搜索作修改，使得它能获取主要变例。修改的部分用醒目的颜色标出：</dt>
    <dd>　</dd>
    <dd><font color="#FF0000">typedef struct tagLINE {</font></dd>
    <dd><font color="#FF0000">　int cmove; 　　　　　　//
        路线中着法的数量；</font></dd>
    <dd><font color="#FF0000">　MOVE argmove[moveMAX]; // 路线。</font></dd>
    <dd><font color="#FF0000">} LINE;</font></dd>
    <dd>　</dd>
    <dd>int AlphaBeta(int depth, int alpha, int beta<font
        color="#FF0000">, LINE *pline</font>) {</dd>
    <dd><font color="#FF0000">　LINE line;</font></dd>
    <dd>　if (depth == 0) {</dd>
    <dd><font color="#FF0000">　　pline-&gt;cmove = 0;</font></dd>
    <dd>　　return Evaluate();</dd>
    <dd>　}</dd>
    <dd>　GenerateLegalMoves();</dd>
    <dd>　while (MovesLeft()) {</dd>
    <dd>　　MakeNextMove();</dd>
    <dd>　　val = -AlphaBeta(depth - 1, -beta, -alpha<font
        color="#FF0000">, &amp;line</font>);</dd>
    <dd>　　UnmakeMove();</dd>
    <dd>　　if (val &gt;= beta) {</dd>
    <dd>　　　return beta;</dd>
    <dd>　　}</dd>
    <dd>　　if (val &gt; alpha) {</dd>
    <dd>　　　alpha = val;</dd>
    <dd><font color="#FF0000">　　　pline-&gt;argmove[0] =
        ThisMove();</font></dd>
    <dd><font color="#FF0000">　　　memcpy(pline-&gt;argmove +
        1, line.argmove, line.cmove * sizeof(MOVE));</font></dd>
    <dd><font color="#FF0000">　　　pline-&gt;cmove = line.cmove
        + 1;</font></dd>
    <dd>　　}</dd>
    <dd>　}</dd>
    <dd>　return alpha;</dd>
    <dd>}</dd>
    <dt>　</dt>
    <dt>　　这个函数或许效率很低，因为它用到很多的堆栈空间，但是代码工作起来并不慢。有了这些改动后，如果函数返回<font
        face="Times New Roman">Alpha</font>和<font
        face="Times New Roman">Beta</font>之间的值，那么它不仅仅返回一个值，还包括能产生这个值的路线<font
        face="Times New Roman">(</font>一系列预测的着法<font
        face="Times New Roman">)</font>。这对于搜索树的任何结点都是有效的，包括根结点<font
        face="Times New Roman">(</font>它是最值得这么做的<font
        face="Times New Roman">)</font>。你可以这么来调用<font
        face="Times New Roman">Alpha-Beta</font>：</dt>
    <dd>　</dd>
    <dd>val = AlphaBeta(depth, -INFINITY, INFINITY, &amp;line);</dd>
    <dt>　</dt>
    <dt>　　你得到的是局面的值，以及在“<font
        face="Times New Roman">line</font>”这个存储区里保存的预测路线。“<font
        face="Times New Roman">line</font>”的数据结构是一个着法数组，以构成一个路线，另有一个整数来告诉你路线中有多少着法。</dt>
    <dt>　　如果你用深度等于零去调用<font
        face="Times New Roman">Alpha-Beta</font>，那么这个函数只调用“<font
        face="Times New Roman">Evaluate()</font>”并返回它的值。一个着法也没搜索，因此一个着法也没选择，从而和分值一起返回的路线其长度为零。</dt>
    <dt>　　如果你用某个深度调用这个搜索函数，那么你可以找到一个着法其值在<font
        face="Times New Roman">Alpha</font>和<font
        face="Times New Roman">Beta</font>之间，而你得到的不仅仅是分值，而且包括能产生这个值的一系列着法。为了在<font
        face="Times New Roman">Alpha-Beta</font>过程中建立路线，你拿出这个搜索到的着法，把它存入传递的路线存储区中<font
        color="#0000FF">【译注：即函数中的“</font><font
        color="#0000FF" face="Times New Roman">*pline</font><font
        color="#0000FF">”】</font>，并把局部的路线存储区<font
        color="#0000FF">【即函数中的“</font><font
        color="#0000FF" face="Times New Roman">line</font><font
        color="#0000FF">”】</font>也加到传递的存储区中。</dt>
    <dt>　　你可能会问：“既然有传过来的路线存储区，为什么又要在每次递归的堆栈中新分配一个？”因为你在搜索树中找到一个局部的线路，那么原来的线路被推翻了，但你不能毁坏已经建立好的线路。如果你找到某个返回值在<font
        face="Times New Roman">Alpha</font>和<font
        face="Times New Roman">Beta</font>之间的结点，你就认为这个结点在搜索树的根结点的路线上，这是不对的。有很多零碎的主要变例是被丢弃的。</dt>
    <dt>　　让你们感到惊讶的是，我在循环内用了“<font
        face="Times New Roman">memcpy</font>”这个函数<font
        color="#0000FF">【事实上这也是个循环，因此可能会认为它的效率很低】</font>，它几乎不花时间，因为它很少被执行。</dt>
    <dt>　</dt>
    <dt><font size="5" face="楷体_GB2312"><strong>另一个思想</strong></font></dt>
    <dt>　</dt>
    <dt>　　另一个一目了然的方法，就是在搜索值返回后，从主置换表中提取主要变例。置换表项中有一个区域存放这局面的最佳着法。由于每个<font
        face="Times New Roman">PV</font>结点都有一个值在<font
        face="Times New Roman">Alpha</font>和<font
        face="Times New Roman">Beta</font>之间，散列项中必定保存着“最佳着法”。</dt>
    <dt>　　从置换表中提取主要变例，可以沿着散列项组成的链来提取，这就像吃馅饼一样简单。</dt>
    <dt>　　我知道很多程序<font face="Times New Roman">(</font>包括一些专业程序<font
        face="Times New Roman">)</font>是这样做的，但是我没有试过。</dt>
    <dt><font color="#0000FF">　　【情况可能会比想象中的复杂，因为置换表中的数据会被覆盖，这样做就必须选择合适的覆盖策略。显然根结点是不会被覆盖的</font><font
        color="#0000FF" face="Times New Roman">(</font><font
        color="#0000FF">它总是最后一个写入置换表</font><font
        color="#0000FF" face="Times New Roman">)</font><font
        color="#0000FF">，因此至少能提取出一个着法</font><font
        color="#0000FF" face="Times New Roman">(</font><font
        color="#0000FF">即程序要走的那步棋</font><font
        color="#0000FF" face="Times New Roman">)</font><font
        color="#0000FF">，但是后续着法就很难保证了。深度优先的覆盖策略会比较有利，除此之外，也可以考虑</font><font
        color="#0000FF" face="Times New Roman">PV</font><font
        color="#0000FF">结点优先的策略，因为</font><font
        color="#0000FF" face="Times New Roman">PV</font><font
        color="#0000FF">结点的数量比</font><font
        color="#0000FF" face="Times New Roman">Alpha</font><font
        color="#0000FF">结点和</font><font color="#0000FF"
        face="Times New Roman">Beta</font><font color="#0000FF">结点少得多，所以这个覆盖策略对置换表不会产生很大的影响。</font></dt>
    <dt><font color="#0000FF">　　另外，直接从</font><font
        color="#0000FF" face="Times New Roman">Alpha-Beta</font><font
        color="#0000FF">函数提取的主要变例，会因为置换表的运用而中断，除非置换表里有一项用来存储主要变例</font><font
        color="#0000FF" face="Times New Roman">(</font><font
        color="#0000FF">这不是不可能的，因为</font><font
        color="#0000FF" face="Times New Roman">PV</font><font
        color="#0000FF">结点的数量非常少</font><font
        color="#0000FF" face="Times New Roman">)</font><font
        color="#0000FF">。如果要得到完整的主要变例，可以考虑不在置换表中写入</font><font
        color="#0000FF" face="Times New Roman">PV</font><font
        color="#0000FF">结点</font><font color="#0000FF"
        face="Times New Roman">(</font><font color="#0000FF">某些程序甚至只在置换表中写入</font><font
        color="#0000FF" face="Times New Roman">Beta</font><font
        color="#0000FF">结点</font><font color="#0000FF"
        face="Times New Roman">)</font><font color="#0000FF">。】</font></dt>
    <dt>　</dt>
    <dt>　　原文：<a
        href="http://www.seanet.com/~brucemo/topics/pv.htm"
        target="_blank"><font face="Times New Roman">http://www.seanet.com/~brucemo/topics/pv.htm</font></a></dt>
    <dt>　　译者：象棋百科全书网 <font
        face="Times New Roman">(</font><a
        href="mailto:webmaster@xqbase.com"><font
        face="Times New Roman">webmaster@xqbase.com</font></a><font
        face="Times New Roman">)</font></dt>
    <dt>　　类型：全译加译注</dt>
</dl>

<dir>
    <li>上一篇　<a href="other_winning.htm">其他策略――胜利局面</a></li>
    <li>下一篇　<a href="other_repetition.htm">其他策略――重复检测</a></li>
    <li>返　回　<a href="../computer.htm">象棋百科全书――电脑象棋</a></li>
</dir>
<div align="center"><center>

<table border="0">
    <tr>
        <td><p align="center"><a
        href="http://www.xqbase.com/" target="_blank"><img
        src="../xqbase.gif" border="0" width="88"
        height="31"></a></p>
        </td>
    </tr>
    <tr>
        <td><a href="http://www.xqbase.com/"
        target="_blank"><font size="2" face="Arial"><strong>www.xqbase.com</strong></font></a></td>
    </tr>
</table>
</center></div>
</body>
</html>
