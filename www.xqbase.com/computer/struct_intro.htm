<html>

<head>
<meta http-equiv="Content-Type"
content="text/html; charset=gb_2312-80">
<meta name="Owner" content>
<meta name="Reply-To" content>
<meta name="GENERATOR" content="Microsoft FrontPage Express 2.0">
<title>数据结构――简介</title>
</head>

<body background="../background.gif">

<dl>
    <div align="center"><center>
    <dt><font size="3">《对弈程序基本技术》专题</font></dt>
    </center></div><div align="center"><center>
    <dt>　</dt>
    </center></div><div align="center"><center>
    <dt><font size="6" face="隶书">棋盘的表示</font></dt>
    </center></div><div align="center"><center>
    <dt>　</dt>
    </center></div><div align="center"><center>
    <dt><font face="Times New Roman">David Eppstein */</font>文</dt>
    </center></div><div align="center"><center>
    <dt><font face="Times New Roman">* </font>加州爱尔文大学<font
        face="Times New Roman">(UC Irvine)</font>信息与计算机科学系</dt>
    </center></div>
    <dt>　</dt>
    <dt>　　要让机器下棋，程序首先必须对两个对象进行存储和操作，它们是局面和着法。这两个对象的表示使得程序可以进行下列操作：</dt>
    <dt>　　<font face="Times New Roman">(1) </font>执行一个着法<font
        face="Times New Roman">(</font>不仅仅是用户所指出的着法，而是在搜索过程中要用到的<font
        face="Times New Roman">)</font>；</dt>
    <dt>　　<font face="Times New Roman">(2) </font>撤消一个着法<font
        face="Times New Roman">(</font>作用同上<font
        face="Times New Roman">)</font>；</dt>
    <dt>　　<font face="Times New Roman">(3) </font>向用户显示棋盘；</dt>
    <dt>　　<font face="Times New Roman">(4) </font>产生所有可能的着法；</dt>
    <dt>　　<font face="Times New Roman">(5) </font>对棋盘的局面作出评估。</dt>
    <dt>　　除了显示棋盘以外，所有的操作都应该尽可能地迅速，因为它们会在搜索的循环内被调用。<font
        face="Times New Roman">(</font>而显示棋盘的操作毕竟不是经常要做的。<font
        color="#0000FF">【译注：在</font><font
        color="#0000FF" face="Times New Roman">UCI</font><font
        color="#0000FF">协议</font><font color="#0000FF"
        face="Times New Roman">(</font><font color="#0000FF">国际象棋通用引擎协议</font><font
        color="#0000FF" face="Times New Roman">)</font><font
        color="#0000FF">中，引擎从不显示棋盘，因此这个操作事实上是多余的。】</font><font
        face="Times New Roman">)</font></dt>
    <dt>　　着法的内部表示应该是非常简洁的<font
        face="Times New Roman">(</font>因为我们不需要花太多的时间来生成一系列着法<font
        face="Times New Roman">)</font>而且能快速解读，但是非常重要的是，它应该能代表所有的着法！在国际象棋中，机器内典型的着法表示，就是记录移动棋子的起点格子和终点格子，例如王前兵进两格就表示为“<font
        face="Times New Roman">e2e4</font>”<font
        face="Times New Roman">(e2</font>代表这个兵起点位置而<font
        face="Times New Roman">e4</font>代表终点位置<font
        face="Times New Roman">)</font>。不管是否吃子，被吃的棋子都不必记录，因为它可以由终点格子来判断。在机器中位置能表示为<font
        face="Times New Roman">6</font>位的数值，所以一个着法可以用<font
        face="Times New Roman">2</font>个字节表示。尽管很多程序都是这样表示的，但是这种表示方法不足以表示所有的着法！王车易位时，有两个子要移动，此时我们把它当作特殊情况来考虑，只记录王的移动。问题在于，当兵从第七行走到第八行时，可以升变为后、车、马或象，上述表示方法不能让我们指定升变为哪个棋子。因此在设计着法表示时需要非常仔细，要确认这种表示能够涵盖棋局中所有可能发生的特殊情况。</dt>
    <dt><font color="#0000FF">　　【一般而言，棋类的着法有两种形式，即添子式和移动式。五子棋、围棋、黑白棋等属于添子式，记录着法时只要记录棋子所下到的那个格子。其中五子棋最简单，下完的棋子不再会改变；黑白棋稍复杂些，下完的棋子可能会被后续着法所变换黑白，但每下一子棋盘上就多一子；围棋是最复杂的，由于存在提子的着法，所以局势是可逆的，打劫这样的着法需要很复杂的处理过程。</font></dt>
    <dt><font color="#0000FF">　　国际象棋和中国象棋都属于移动式，相比较而言中国象棋更简单，当一个棋子从起点移到终点时，只要简单地做一下终点的覆盖即可；而国际象棋由于三条特殊规则的存在而必须做特别处理，有时别的特殊位置的棋子要跟着移动</font><font
        color="#0000FF" face="Times New Roman">(</font><font
        color="#0000FF">王车易位</font><font color="#0000FF"
        face="Times New Roman">)</font><font color="#0000FF">，有时别的特殊位置的子要被吃掉</font><font
        color="#0000FF" face="Times New Roman">(</font><font
        color="#0000FF">吃过路兵</font><font color="#0000FF"
        face="Times New Roman">)</font><font color="#0000FF">，有时移动的棋子要被其他棋子所替代</font><font
        color="#0000FF" face="Times New Roman">(</font><font
        color="#0000FF">升变</font><font color="#0000FF"
        face="Times New Roman">)</font><font color="#0000FF">。】</font></dt>
    <dt>　　棋盘的表示可能稍许复杂了些，但也不应该太庞大。它必须包括所有相关的信息，而不仅仅是表观上的，但无关的信息不包括在其中。例如在国际象棋里，我们必须知道棋子在棋盘上的位置<font
        face="Times New Roman">(</font>表观上的信息<font
        face="Times New Roman">)</font>，而且需要知道一些不可见的信息――现在是谁在走，每方是否还有易位权，哪个过路兵可以吃，从吃子或进兵到现在一共走了多少步。我们还需要知道以前发生过哪些重复的局面<font
        face="Times New Roman">(</font>因为三次重复局面即导致和棋<font
        face="Times New Roman">)</font>，而不需要知道以前所有的着法。</dt>
    <dt><font color="#0000FF">　　【在网络通讯中常常用一种称为</font><font
        color="#0000FF" face="Times New Roman">FEN</font><font
        color="#0000FF">串的</font><font color="#0000FF"
        face="Times New Roman">6</font><font color="#0000FF">段式代码来记录局面，在国际象棋中它的</font><font
        color="#0000FF" face="Times New Roman">6</font><font
        color="#0000FF">段代码依次为：棋盘、走子方、王车易位权、吃过路兵的目标格、可逆着法数以及总回合数，基本上涵盖了国际象棋某个局面的所有信息。但是</font><font
        color="#0000FF" face="Times New Roman">FEN</font><font
        color="#0000FF">字符串无法记录重复局面，因此</font><font
        color="#0000FF" face="Times New Roman">UCI</font><font
        color="#0000FF">协议中规定，局面由棋局的最后一个不可逆局面</font><font
        color="#0000FF" face="Times New Roman">(</font><font
        color="#0000FF">发生吃子、进兵或升变的局面</font><font
        color="#0000FF" face="Times New Roman">)</font><font
        color="#0000FF">和它的后续着法共同表示，这样就涵盖了重复局面的信息。】</font></dt>
    <dt>　</dt>
    <dt><font size="5" face="楷体_GB2312"><strong>举例说明国际象棋中的诸多棋盘表示方法</strong></font></dt>
    <dt>　</dt>
    <dt>　　国际象棋中有很多表示棋盘的方法，以下这些是程序中可能用到的：</dt>
    <dt>　</dt>
    <dt><font size="3" face="楷体_GB2312"><strong>　　</strong></font><font
        size="4" face="楷体_GB2312"><strong>一、棋盘格子的</strong></font><font
        size="4" face="Arial"><strong>8x8</strong></font><font
        size="4" face="楷体_GB2312"><strong>数组</strong></font></dt>
    <dt>　　每个格子的值代表格子中的棋子<font
        face="Times New Roman">(</font>例如：<font
        face="Times New Roman">enum { empty, wK, wN, wB, wR, wQ,
        wP, bK, bN, bR, bQ, bP })</font>。它的优点在于：<font
        face="Times New Roman">(1) </font>简单；<font
        face="Times New Roman">(2) </font>容易计算子力价值：</dt>
    <dd>　</dd>
    <dd>for (i = 0; i &lt; 8; i ++)</dd>
    <dd>　for( j = 0; j &lt; 8; j ++)</dd>
    <dd>　　score += value[square[i, j]];</dd>
    <dt>　</dt>
    <dt>　　计算可能的着法有些麻烦但并不非常困难，可以找遍棋盘的每个格子，根据棋子的颜色和类型来做分枝：</dt>
    <dd>　</dd>
    <dd>for (i = 0; i &lt; 8; i++) {</dd>
    <dd>　for(j = 0; j &lt; 8; j++) {</dd>
    <dd>　　switch (board[i, j]) {</dd>
    <dd>　　case wP:</dd>
    <dd>　　　if (board[i + 1, j] = empty) {</dd>
    <dd>　　　　生成到(i + 1, j)的着法;</dd>
    <dd>　　　}</dd>
    <dd>　　　if (i == 2 &amp;&amp; board[i + 1, j] == empty
        &amp;&amp; board[i + 2, j] empty) {</dd>
    <dd>　　　　生成到(i + 2, j)的着法;</dd>
    <dd>　　　}</dd>
    <dd>　　　if (j &gt; 0 &amp;&amp; board[i + 1, j - 1]有黑子)
        {</dd>
    <dd>　　　　生成吃(i + 1, j - 1)子的着法;</dd>
    <dd>　　　}</dd>
    <dd>　　　if (j &lt; 7 &amp;&amp; board[i + 1, j + 1]有黑子)
        {</dd>
    <dd>　　　　生成吃(i + 1, j + 1)子的着法;</dd>
    <dd>　　　}</dd>
    <dd>　　　break;</dd>
    <dd>　　　...</dd>
    <dd>　　}</dd>
    <dd>　}</dd>
    <dd>}</dd>
    <dt>　</dt>
    <dt>　　但是很多检测边界的判断<font
        face="Times New Roman">(</font>例如，兵在车一路就不能吃更外侧的子<font
        face="Times New Roman">)</font>，使得代码非常复杂，速度非常缓慢。</dt>
    <dt>　</dt>
    <dt><font face="楷体_GB2312"><strong>　　</strong></font><font
        size="4" face="楷体_GB2312"><strong>二、扩展数组</strong></font></dt>
    <dt>　　包括扩展边界的<font face="Times New Roman">10x10</font>数组，在棋子类型中应包括“<font
        face="Times New Roman">boundary</font>”这个值。这样就可以花很少的代价，来简化一些判断。<font
        color="#0000FF">【在下面提到的</font><font
        color="#0000FF" face="Times New Roman">0x88</font><font
        color="#0000FF">方法问世以前，最普遍的做法却是用</font><font
        color="#0000FF" face="Times New Roman">12x12</font><font
        color="#0000FF">的数组</font><font color="#0000FF"
        face="Times New Roman">(</font><font color="#0000FF">即有双重的扩展边界</font><font
        color="#0000FF" face="Times New Roman">)</font><font
        color="#0000FF">，这样连马的着法也不用担心跳出棋盘了。】</font></dt>
    <dt>　</dt>
    <dt>　　<font size="4" face="楷体_GB2312"><strong>三、</strong></font><font
        size="4" face="Arial"><strong>0x88</strong></font></dt>
    <dt>　　这个名称来自一个技巧――通过判断格子编码是否包含<font
        face="Times New Roman">136</font>这个数<font
        face="Times New Roman">(</font>在<font
        face="Times New Roman">16</font>进制中是<font
        face="Times New Roman">0x88)</font>来检测着法是否合理。下表就是格子的编码<font
        face="Times New Roman">(</font>用一个字节<font
        face="Times New Roman">)</font>，高<font
        face="Times New Roman">4</font>位表示行，低<font
        face="Times New Roman">4</font>位表示列。</dt>
</dl>

<dl>
    <dd><table border="1">
            <tr>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>120</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>121</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>122</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>123</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>124</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>125</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>126</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>127</strong></font></td>
            </tr>
            <tr>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>96</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>97</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>98</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>99</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>100</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>101</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>102</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>103</strong></font></td>
            </tr>
            <tr>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>80</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>81</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>82</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>83</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>84</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>85</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>86</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>87</strong></font></td>
            </tr>
            <tr>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>64</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>65</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>66</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>67</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>68</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>69</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>70</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>71</strong></font></td>
            </tr>
            <tr>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>48</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>49</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>50</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>51</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>52</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>53</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>54</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>55</strong></font></td>
            </tr>
            <tr>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>32</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>33</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>34</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>35</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>36</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>37</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>38</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>39</strong></font></td>
            </tr>
            <tr>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>16</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>17</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>18</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>19</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>20</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>21</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>22</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>23</strong></font></td>
            </tr>
            <tr>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>0</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>1</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>2</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>3</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>4</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>5</strong></font></td>
                <td align="center" bgcolor="#000000"><font
                color="#FFFFFF" face="Times New Roman"><strong>6</strong></font></td>
                <td align="center" bgcolor="#FFFFFF"><font
                face="Times New Roman"><strong>7</strong></font></td>
            </tr>
        </table>
    </dd>
    <dt>　</dt>
    <dt>　　这样，格子<font face="Times New Roman"><em>i</em></font>的左边一格是<font
        face="Times New Roman"><em>i</em> </font><font
        face="Symbol">-</font><font face="Times New Roman"> 1</font>，右边是<font
        face="Times New Roman"><em>i</em> + 1</font>，上边是<font
        face="Times New Roman"><em>i</em> + 16</font>，下边是<font
        face="Times New Roman"><em>i</em> </font><font
        face="Symbol">-</font><font face="Times New Roman"> 16</font>，等等。棋盘被表示为<font
        face="Times New Roman">128</font>个格子的数组<font
        face="Times New Roman">(</font>其中<font
        face="Times New Roman">64</font>格代表棋盘上存在的格子<font
        face="Times New Roman">)</font>，这种表示的优势在于：<font
        face="Times New Roman">(1) </font>数组仅用<font
        face="Times New Roman">1</font>个指标，这样写的程序要比用<font
        face="Times New Roman">2</font>个指标快；<font
        face="Times New Roman">(2) </font>可以快速简单地判断某个格子<font
        face="Times New Roman"><em>i</em></font>是否在棋盘上――当且仅当<font
        face="Times New Roman">(i &amp; 0x88) == 0</font>时<font
        face="Times New Roman"><em>i</em></font>在棋盘上。<font
        face="Times New Roman">(</font>因为列超出范围时<font
        face="Times New Roman"><em>i</em> &amp; 0x08</font>不为零，而行超出范围时<font
        face="Times New Roman"><em>i</em> &amp; 0x80</font>不为零。<font
        face="Times New Roman">)</font>这是一个非常有效而且常用的技巧。</dt>
    <dt>　</dt>
    <dt>　　<font size="4" face="楷体_GB2312"><strong>四、位棋盘</strong></font></dt>
    <dt>　　我必须在这里多花些笔墨，因为这个技术还不被人所熟悉，但是我认为它可能会很好用的。以前用一个格子数组，每个元素含有一个棋子，现在取而代之的是一个棋子数组，每个元素代表棋盘上哪几个格子有这个棋子，按位压缩表示。由于棋盘上有<font
        face="Times New Roman">64</font>个格子，所以棋盘可以压缩成一个<font
        face="Times New Roman">64</font>位的字<font
        face="Times New Roman">(</font>即两个<font
        face="Times New Roman">32</font>位的字<font
        face="Times New Roman">)</font>。这种表示最大的优势在于，可以通过布尔操作<font
        face="Times New Roman">(</font>位操作<font
        face="Times New Roman">)</font>来加快局面评估和着法生成操作的速度。试想一下，如此烦琐的事情可以用压缩的字运算来解决，例如下面的局面：</dt>
    <dt>　</dt>
    <div align="center"><center>
    <dt><img src="struct_intro.gif" width="256" height="256"></dt>
    </center></div>
    <dt>　</dt>
    <dt>　　白方的兵<font face="Times New Roman">(</font>这个<font
        face="Times New Roman">64</font>位数字记作<font
        face="Times New Roman">wP)</font>应该由这些位构成：</dt>
    <dt>　</dt>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>0 0 0 0 0 1 0 0</dd>
    <dd>0 0 0 0 0 1 0 0</dd>
    <dd>0 0 0 0 1 0 0 0</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>1 1 1 0 0 0 0 1</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dt>　</dt>
    <dt>　　而被黑方占据的格子可以用下面的公式来计算：</dt>
    <dt>　</dt>
    <dd>bOcc = bP | bN | bB | bR | bQ | bK</dd>
    <dt>　</dt>
    <dt>　　<font face="Times New Roman">(</font>这里<font
        face="Times New Roman">bP</font>等等代表黑方不同兵种的棋子<font
        face="Times New Roman">)</font>，类似地可以计算白方占据的格子，还可以把这两个格子作“或”运算得到所有被占的格子。这些白兵前进一格可能到达的格子，可以用下面的公式计算：</dt>
    <dt>　</dt>
    <dd>single_pawn_moves = (wP &lt;&lt; 8) &amp; ~occupied</dd>
    <dt>　</dt>
    <dt>　　现在仔细看一下过程，先将<font
        face="Times New Roman">wP</font>左移<font
        face="Times New Roman">8</font>位，来产生每个兵前面的格子：</dt>
    <dt>　</dt>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>0 0 0 0 0 1 0 0</dd>
    <dd>0 0 0 0 0 1 0 0</dd>
    <dd>0 0 0 0 1 0 0 0</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>1 1 1 0 0 0 0 1</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dt>　</dt>
    <dt>　　然后求被占格子的“非”运算得到空的格子：</dt>
    <dt>　</dt>
    <dd>0 0 1 1 0 0 1 0</dd>
    <dd>1 0 1 0 1 0 0 0</dd>
    <dd>1 1 1 0 0 0 1 1</dd>
    <dd>1 0 1 1 1 0 1 1</dd>
    <dd>1 0 1 1 0 1 1 1</dd>
    <dd>1 0 1 1 1 0 1 1</dd>
    <dd>0 0 0 1 1 1 1 0</dd>
    <dd>0 1 0 1 0 0 1 0</dd>
    <dt>　</dt>
    <dt>　　对以上两个位棋盘按位作“与”运算，就得到这些兵前面的没有被占的格子了：</dt>
    <dt>　</dt>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>0 0 0 0 1 0 0 0</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>1 0 1 0 0 0 0 1</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dt>　</dt>
    <dt>　　参照兵走一格的方法，可以找到兵走两格的着法，即再左移<font
        face="Times New Roman">8</font>位，“与”上没有子的格子，再“与”上一个只有第四行都占满的常数棋盘<font
        face="Times New Roman">(</font>这是兵走两格能到达的唯一一行<font
        face="Times New Roman">)</font>：</dt>
    <dt>　</dt>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>1 1 1 1 1 1 1 1</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dd>0 0 0 0 0 0 0 0</dd>
    <dt>　</dt>
    <dt>　　值得注意的是，这个常数棋盘是在编译的时候生成的，而不需要在每次着法生成的时候再计算出来。兵吃子的情况也类似，先左移<font
        face="Times New Roman">7</font>位或<font
        face="Times New Roman">9</font>位，再“与”上一个常数棋盘以过滤左边线或右边线的格子<font
        color="#0000FF">【对于左移</font><font
        color="#0000FF" face="Times New Roman">7</font><font
        color="#0000FF">位产生吃右边子时，需要考虑子在右边线的情况，此时左移</font><font
        color="#0000FF" face="Times New Roman">7</font><font
        color="#0000FF">位是同一行的左边线，因此需要排除这个格子，即“与”上一个常数棋盘，代表除左边线以外的所有格子】</font>，最后“与”上<font
        face="Times New Roman">bOcc</font><font color="#0000FF">【前面提到过这个棋盘，代表黑子所占的格子】</font>。</dt>
    <dt>　　位棋盘这个技术不能简化代码，但是它能一次就产生兵的所有着法，而不是一次只产生一个着法。此外，这个过程中有些表达式需要多次反复使用<font
        face="Times New Roman">(</font>例如<font
        face="Times New Roman">bOcc)</font>，但只要计算一次就可以了。因此，位棋盘最终变得非常高效，在棋子数比国际象棋少的棋类中，我想位棋盘的效果会更好。</dt>
    <dt>　　有个复杂的问题产生了：计算位棋盘中有多少非零位，或者找到<font
        color="#0000FF">【最低或最高的】</font>一个非零位<font
        face="Times New Roman">(</font>例如把兵可以到达的位棋盘转化为一系列着法)，这些操作往往非常重要。计算位数的操作可以一次计算一个字节，做一个长度为<font
        face="Times New Roman">256</font>的数组，每个元素代表它的指标所含有多少个非零位，然后通过查表来完成。在找到一个非零位的计算中有个技巧：<font
        face="Times New Roman"><em>x</em> ^ (<em>x</em> </font><font
        face="Symbol">-</font><font face="Times New Roman"> 1)(</font>“<font
        face="Times New Roman">^</font>”代表异或<font
        face="Times New Roman">)</font>，会得到一个二进制为<font
        face="Times New Roman">...000111...</font>的数，<font
        face="Times New Roman"><em>x</em> ^ (<em>x</em> </font><font
        face="Symbol">-</font><font face="Times New Roman"> 1)</font>的第一位就是<font
        face="Times New Roman"><em>x</em></font>的最后一位非零位。如果要求得这个数字<font
        color="#0000FF">【</font><font color="#0000FF"
        face="Times New Roman"><em>x</em> ^ (<em>x</em> </font><font
        color="#0000FF" face="Symbol">-</font><font
        color="#0000FF" face="Times New Roman"> 1)</font><font
        color="#0000FF">，即型如</font><font color="#0000FF"
        face="Times New Roman">...000111...</font><font
        color="#0000FF">的数】</font>的第一位，就把它对某个特定的数<font
        face="Times New Roman">M</font>取余数<font
        face="Times New Roman">(</font>不同的<font
        face="Times New Roman">...000111...</font>这样的数对<font
        face="Times New Roman">M</font>取余数必须不同<font
        face="Times New Roman">)</font>，然后去查表。例如，以下的代码可以找到一个字节的最后一个非零位：</dt>
    <dd>　</dd>
    <dd>int T = { -1, 0, 7, 1, 3, -1, 6, 2, 5, 4, -1, -1 };</dd>
    <dd>int last_bit(unsigned char b) {</dd>
    <dd>　return T[(b^(b-1)) % 11];</dd>
    <dd>}</dd>
    <dt>　</dt>
    <dt>　　<font color="#0000FF">【把原作者提到的这个技巧扩展到</font><font
        color="#0000FF" face="Times New Roman">16</font><font
        color="#0000FF">位或</font><font color="#0000FF"
        face="Times New Roman">32</font><font color="#0000FF">位的情况，不妨可以试探一下</font><font
        color="#0000FF" face="Times New Roman">(</font><font
        color="#0000FF">只要找得到合适的除数即可</font><font
        color="#0000FF" face="Times New Roman">)</font><font
        color="#0000FF">。但是原作者没有充分考虑计算机的运算特点，因此译者认为这不是一个合理的设计。由于“电脑一做除法就成了傻瓜”，所以代码中取余数的过程严重影响了效率，为此译者收集了一些使用炫技的程序，可以迅速完成求位数和查找位的操作。</font></dt>
    <dt><font color="#0000FF">　　</font><font color="#0000FF"
        face="Times New Roman">(1) </font><font color="#0000FF">求一个</font><font
        color="#0000FF" face="Times New Roman">32</font><font
        color="#0000FF">位数中有几位非零位的运算――</font><font
        color="#0000FF" face="Times New Roman">Count32</font><font
        color="#0000FF">操作：</font></dt>
    <dd>　</dd>
    <dd><font color="#0000FF">int Count32(unsigned long Arg) {</font></dd>
    <dd><font color="#0000FF">　Arg = ((Arg &gt;&gt; 1) &amp; 0x55555555)
        + (Arg &amp; 0x55555555);</font></dd>
    <dd><font color="#0000FF">　Arg = ((Arg &gt;&gt; 2) &amp; 0x33333333)
        + (Arg &amp; 0x33333333);</font></dd>
    <dd><font color="#0000FF">　Arg = ((Arg &gt;&gt; 4) &amp; 0x0f0f0f0f)
        + (Arg &amp; 0x0f0f0f0f);</font></dd>
    <dd><font color="#0000FF">　Arg = ((Arg &gt;&gt; 8) &amp; 0x00ff00ff)
        + (Arg &amp; 0x00ff00ff);</font></dd>
    <dd><font color="#0000FF">　return (Arg &gt;&gt; 16) + (Arg
        &amp; 0x0000ffff);</font></dd>
    <dd><font color="#0000FF">}</font></dd>
    <dt>　</dt>
    <dt><font color="#0000FF">　　</font><font color="#0000FF"
        face="Times New Roman">(2) </font><font color="#0000FF">求最低位非零位是第几位的运算――</font><font
        color="#0000FF" face="Times New Roman">Lsb32</font><font
        color="#0000FF">操作</font><font color="#0000FF"
        face="Times New Roman">(LSB = Least Significant Bit)</font><font
        color="#0000FF">：</font></dt>
    <dd>　</dd>
    <dd><font color="#0000FF">int Lsb32(unsigned long Arg) {</font></dd>
    <dd><font color="#0000FF">　int RetVal = 31;</font></dd>
    <dd><font color="#0000FF">　if (Arg &amp; 0x0000ffff) {
        RetVal -= 16; Arg &amp;= 0x0000ffff; }</font></dd>
    <dd><font color="#0000FF">　if (Arg &amp; 0x00ff00ff) {
        RetVal -= 8; Arg &amp;= 0x00ff00ff; }</font></dd>
    <dd><font color="#0000FF">　if (Arg &amp; 0x0f0f0f0f) {
        RetVal -= 4; Arg &amp;= 0x0f0f0f0f; }</font></dd>
    <dd><font color="#0000FF">　if (Arg &amp; 0x33333333) {
        RetVal -= 2; Arg &amp;= 0x33333333; }</font></dd>
    <dd><font color="#0000FF">　if (Arg &amp; 0x55555555) RetVal
        -=1;</font></dd>
    <dd><font color="#0000FF">　return RetVal;</font></dd>
    <dd><font color="#0000FF">}</font></dd>
    <dt>　</dt>
    <dt><font color="#0000FF">　　</font><font color="#0000FF"
        face="Times New Roman">(3) </font><font color="#0000FF">求最高位非零位是第几位的运算――</font><font
        color="#0000FF" face="Times New Roman">Msb32</font><font
        color="#0000FF">操作</font><font color="#0000FF"
        face="Times New Roman">(MSB = Most Significant Bit)</font><font
        color="#0000FF">：</font></dt>
    <dd>　</dd>
    <dd><font color="#0000FF">int Msb32(unsigned long Arg) {</font></dd>
    <dd><font color="#0000FF">　int RetVal = 0;</font></dd>
    <dd><font color="#0000FF">　if (Arg &amp; 0xffff0000) {
        RetVal += 16; Arg &amp;= 0xffff0000; }</font></dd>
    <dd><font color="#0000FF">　if (Arg &amp; 0xff00ff00) {
        RetVal += 8; Arg &amp;= 0xff00ff00; }</font></dd>
    <dd><font color="#0000FF">　if (Arg &amp; 0xf0f0f0f0) {
        RetVal += 4; Arg &amp;= 0xf0f0f0f0; }</font></dd>
    <dd><font color="#0000FF">　if (Arg &amp; 0xcccccccc) {
        RetVal += 2; Arg &amp;= 0xcccccccc; }</font></dd>
    <dd><font color="#0000FF">　if (Arg &amp; 0xaaaaaaaa) RetVal
        += 1;</font></dd>
    <dd><font color="#0000FF">　return RetVal;</font></dd>
    <dd><font color="#0000FF">}</font></dd>
    <dt>　</dt>
    <dt><font color="#0000FF">　　对</font><font
        color="#0000FF" face="Times New Roman">64</font><font
        color="#0000FF">位数字进行操作，把它分解成两个</font><font
        color="#0000FF" face="Times New Roman">32</font><font
        color="#0000FF">位字，分别对两个字调用上面的函数就可以了。如果程序能运行在</font><font
        color="#0000FF" face="Times New Roman">64</font><font
        color="#0000FF">位的处理器上，只要对上面三个函数略加改动就可以了。】</font></dt>
    <dt>　</dt>
    <dt><font size="5" face="楷体_GB2312"><strong>如何撤消着法？</strong></font></dt>
    <dt>　</dt>
    <dt>　　还记得吗？我们说过在棋盘表示方法中需要涉及撤消着法的操作。现在有两种解决方案：<font
        face="Times New Roman">(1) </font>用一个堆栈来保存棋盘，执行一个着法前先将棋盘压入堆栈，撤消着法就从堆栈弹出棋盘，恐怕这太慢了……
        <font face="Times New Roman">(2) </font>用一个堆栈来保存着法，执行一个着法前先将该着法及其相关信息压入堆栈，撤消着法就根据该着法还原棋盘及其相关信息。例如，在国际象棋中只要保存被吃的棋子<font
        face="Times New Roman">(</font>如果吃子的话<font
        face="Times New Roman">)</font>，以及王车易位和吃过路兵的权利等信息。</dt>
    <dt>　</dt>
    <dt><font size="5" face="楷体_GB2312"><strong>重复检测</strong></font></dt>
    <dt>　</dt>
    <dt>　　某些棋类在发生重复局面时要用到特殊的规则，如围棋和国际象棋<font
        face="Times New Roman">(</font>在国际象棋中，第三次出现重复局面时，制造重复局面的一方就有权宣布和棋<font
        face="Times New Roman">)</font>。那么如何知道是否出现重复局面呢？答案很简单：用散列函数把局面转换成一个相当大的数<font
        face="Times New Roman">(</font>我们以后要谈到这个问题，因为这个技术还可以加快搜索速度<font
        face="Times New Roman">)</font>，然后保存一系列前面出现过的局面的散列值，从这些值里面找就是了。一个典型的散列函数，先随机产生一张<font
        face="Times New Roman">64x13</font>的表，如果棋子<font
        face="Times New Roman"><em>y</em></font>在位置<font
        face="Times New Roman"><em>x</em></font>上，就把表中<font
        face="Times New Roman">[<em>x</em>, <em>y</em>]</font>这个数加到散列值上<font
        face="Times New Roman">(</font>忽略溢出<font
        face="Times New Roman">)[</font>即<font
        face="Times New Roman">Zobrist</font>值<font
        face="Times New Roman">]</font>。值得注意的是，当棋子<font
        face="Times New Roman"><em>y</em></font>从位置<font
        face="Times New Roman"><em>x</em></font>走到位置<font
        face="Times New Roman"><em>z</em></font>时，可以快速地更新散列值：减去<font
        face="Times New Roman">[<em>x</em>, <em>y</em>]</font>并加上<font
        face="Times New Roman">[<em>z</em>, <em>y</em>]</font>即可。</dt>
    <dt>　</dt>
    <dt>　　原文：<a
        href="http://www.ics.uci.edu/~eppstein/180a/970408.html"
        target="_blank"><font face="Times New Roman">http://www.ics.uci.edu/~eppstein/180a/970408.html</font></a></dt>
    <dt>　　译者：象棋百科全书网 <font
        face="Times New Roman">(</font><a
        href="mailto:webmaster@xqbase.com"><font
        face="Times New Roman">webmaster@xqbase.com</font></a><font
        face="Times New Roman">)</font></dt>
    <dt>　　类型：全译加译注</dt>
</dl>

<dir>
    <li>上一篇　<a href="outline.htm">概述</a></li>
    <li>下一篇　<a href="struct_bitboard.htm">数据结构――位棋盘</a></li>
    <li>返　回　<a href="../computer.htm">象棋百科全书――电脑象棋</a></li>
</dir>
<div align="center"><center>

<table border="0">
    <tr>
        <td><p align="center"><a
        href="http://www.xqbase.com/" target="_blank"><img
        src="../xqbase.gif" border="0" width="88"
        height="31"></a></p>
        </td>
    </tr>
    <tr>
        <td><a href="http://www.xqbase.com/"
        target="_blank"><font size="2" face="Arial"><strong>www.xqbase.com</strong></font></a></td>
    </tr>
</table>
</center></div>
</body>
</html>
